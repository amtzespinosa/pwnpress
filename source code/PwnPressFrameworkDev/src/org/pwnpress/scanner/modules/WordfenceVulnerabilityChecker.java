package org.pwnpress.scanner.modules;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import org.pwnpress.utils.CustomFormat;

public class WordfenceVulnerabilityChecker {

    public static void checkVersionVulnerabilities(String urlStr) {
        String apiUrl = "https://www.wordfence.com/api/intelligence/v2/vulnerabilities/production";
        // Extract WordPress version
        String wordpressVersion = WPVersion.extractWordPressVersionOnly(urlStr);

        try {
            URL url = new URL(apiUrl);
            HttpURLConnection connection = (HttpURLConnection) url.openConnection();
            connection.setRequestMethod("GET");

            int responseCode = connection.getResponseCode();
            if (responseCode == HttpURLConnection.HTTP_OK) {
                BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                StringBuilder response = new StringBuilder();
                String inputLine;
                while ((inputLine = in.readLine()) != null) {
                    response.append(inputLine);
                }
                in.close();

                JSONObject jsonObject = new JSONObject(response.toString());
                parseAndPrintVulnerabilities(jsonObject, wordpressVersion);
            } else {
                System.out.println("Failed to retrieve data. Response code: " + responseCode);
            }
        } catch (IOException | JSONException e) {
            e.printStackTrace();
        }
    }

    private static void parseAndPrintVulnerabilities(JSONObject jsonObject, String wordpressVersion) {
    	
    	final String ANSI_RESET = "\u001B[0m";
    	
        boolean foundVulnerabilities = false; // Flag to track if any vulnerabilities were found
        try {
            System.out.println("\n[+] Found vulnerabilities:");
            for (String key : jsonObject.keySet()) {
                JSONObject vulnerability = jsonObject.getJSONObject(key);
                JSONArray softwareArray = vulnerability.getJSONArray("software");
                for (int i = 0; i < softwareArray.length(); i++) {
                    JSONObject software = softwareArray.getJSONObject(i);
                    if (software.getString("type").equals("core")) {
                        JSONObject affectedVersions = software.getJSONObject("affected_versions");
                        for (String versionRange : affectedVersions.keySet()) {
                            String[] versions = versionRange.split(" - ");
                            String fromVersion = versions[0];
                            String toVersion = versions.length > 1 ? versions[1] : versions[0];
                            if (isVersionInRange(wordpressVersion, fromVersion, toVersion)) {
                                foundVulnerabilities = true; // Set flag to true if a vulnerability is found
                                System.out.println(CustomFormat.padRight(" |- Title:", 20) + vulnerability.getString("title"));
                                System.out.println(CustomFormat.padRight(" |- References:", 20) + joinJSONArray(vulnerability.getJSONArray("references"), ", "));
                                System.out.println(CustomFormat.padRight(" |- CVE:", 20) + vulnerability.optString("cve", "N/A"));
                                JSONObject cvss = vulnerability.optJSONObject("cvss");
                                String score = cvss != null ? cvss.optString("score", "N/A") : "N/A";
                                String rating = cvss != null ? cvss.optString("rating", "N/A") : "N/A";
                                String color = CustomFormat.getColorForRating(rating); // Determine color based on rating
                                System.out.println(CustomFormat.padRight(" |- Score:", 20) + score);
                                System.out.println(CustomFormat.padRight(" |- Rating:", 20) + color + rating + ANSI_RESET); // Apply color to rating
                                System.out.println(CustomFormat.padRight(" |- Published:", 20) + vulnerability.optString("published", "N/A"));
                                System.out.println(CustomFormat.padRight(" |- Updated:", 20) + vulnerability.optString("updated", "N/A"));
                                System.out.println(" |------------------------------------------------------------------------------");
                            }
                        }
                        break; // Once we find a core vulnerability, no need to check further
                    }
                }
            }
            if (!foundVulnerabilities) {
                System.out.println(" |- No vulnerabilities found.");
            }
        } catch (JSONException e) {
            e.printStackTrace();
        }
    }

    private static boolean isVersionInRange(String version, String fromVersion, String toVersion) {
        if (version.equals("*")) return true; // Match any version
        if (version.compareTo(fromVersion) >= 0 && version.compareTo(toVersion) <= 0) return true;
        return false;
    }

    private static String joinJSONArray(JSONArray array, String delimiter) throws JSONException {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < array.length(); i++) {
            if (i > 0) {
                sb.append(delimiter);
            }
            sb.append(array.getString(i));
        }
        return sb.toString();
    }
    
}
