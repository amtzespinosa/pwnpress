package org.pwnpress.scanner.modules;

import java.util.List;
import java.util.Map;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
import org.pwnpress.utils.CustomFormat;

public class WPPluginsVulnerabilityChecker {

    public static void checkPluginVulnerabilities(JSONObject wfVulnFeed, String urlStr) {
        List<Map<String, String>> foundPlugins = WPPluginScanner.getFoundPlugins(); // Retrieve found themes from WPThemeScanner

        System.out.println("[+] Plugins identified:");
        System.out.println();

        parseAndPrintVulnerabilities(wfVulnFeed, foundPlugins, urlStr);
    }

    private static void parseAndPrintVulnerabilities(JSONObject jsonObject, List<Map<String, String>> foundPlugins, String urlStr) {
        boolean foundVulnerabilities = false;

        try {
            for (Map<String, String> pluginInfo : foundPlugins) {
                String pluginSlug = pluginInfo.get("slug");
                String pluginVersion = pluginInfo.get("version");

                System.out.println("[+] "+pluginInfo.get("slug")+" "+pluginInfo.get("version"));
                System.out.println(" └─ Location: " + urlStr + "wp-content/plugins/" + pluginSlug);
                System.out.println();

                for (String key : jsonObject.keySet()) {
                    JSONObject vulnerability = jsonObject.getJSONObject(key);
                    JSONArray softwareArray = vulnerability.getJSONArray("software");

                    for (int i = 0; i < softwareArray.length(); i++) {
                        JSONObject software = softwareArray.getJSONObject(i);

                        if (software.getString("type").equals("plugin") && software.getString("slug").equals(pluginSlug)) {
                            JSONObject affectedVersions = software.getJSONObject("affected_versions");

                            for (String versionRange : affectedVersions.keySet()) {
                                String[] versions = versionRange.split(" - ");
                                String fromVersion = versions[0];
                                String toVersion = versions.length > 1 ? versions[1] : versions[0];

                                if (isVersionInRange(pluginVersion, fromVersion, toVersion)) {
                                    foundVulnerabilities = true;

                                    JSONObject cvss = vulnerability.optJSONObject("cvss");
                                    String score = cvss != null ? cvss.optString("score", "N/A") : "N/A";
                                    String rating = cvss != null ? cvss.optString("rating", "N/A") : "N/A";
                                    String color = CustomFormat.getColorForRating(rating);

                                    System.out.println(CustomFormat.padRight("    [!] Title:", 20) + vulnerability.getString("title"));
                                    System.out.println(CustomFormat.padRight("     ├─ CVE:", 20) + vulnerability.optString("cve", "N/A"));
                                    System.out.println(CustomFormat.padRight("     ├─ Score:", 20) + score);
                                    System.out.println(CustomFormat.padRight("     ├─ Rating:", 20) + color + rating + CustomFormat.resetColor());
                                    System.out.println(CustomFormat.padRight("     └─ References:", 20) + joinJSONArray(vulnerability.getJSONArray("references"), ", "));
                                    System.out.println();
                                }
                            }
                        }
                    }
                }
            }

            if (!foundVulnerabilities) {
                System.out.println("[✔] No vulnerabilities found in plugins.");
            }
        } catch (JSONException e) {
            e.printStackTrace();
        }
    }

    private static boolean isVersionInRange(String version, String fromVersion, String toVersion) {
        // If version is not found, we cannot compare it
        if (version == null || version.equalsIgnoreCase("Version not found")) {
            return false;
        }

        if (fromVersion.equals("*")) return compareVersions(version, toVersion) <= 0;
        if (toVersion.equals("*")) return compareVersions(version, fromVersion) >= 0;

        return compareVersions(version, fromVersion) >= 0 && compareVersions(version, toVersion) <= 0;
    }

    private static int compareVersions(String version1, String version2) {
        if (version1 == null || version2 == null) return 0; // Avoid null errors

        String[] v1 = version1.split("\\.");
        String[] v2 = version2.split("\\.");

        int maxLength = Math.max(v1.length, v2.length);

        for (int i = 0; i < maxLength; i++) {
            int num1 = (i < v1.length) ? safeParseInt(v1[i]) : 0;
            int num2 = (i < v2.length) ? safeParseInt(v2[i]) : 0;

            if (num1 < num2) return -1;
            if (num1 > num2) return 1;
        }
        return 0;
    }

    // Safe parsing method that returns 0 instead of throwing an error
    private static int safeParseInt(String str) {
        try {
            return Integer.parseInt(str);
        } catch (NumberFormatException e) {
            return 0; // Default to 0 if it's not a number
        }
    }


    private static String joinJSONArray(JSONArray array, String delimiter) throws JSONException {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < array.length(); i++) {
            if (i > 0) {
                sb.append(delimiter);
            }
            sb.append(array.getString(i));
        }
        return sb.toString();
    }
}
