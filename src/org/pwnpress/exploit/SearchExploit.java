package org.pwnpress.exploit;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import org.pwnpress.utils.*;

class Exploit {
    String name;
    String id;
    List<String> tags;
    String versionFrom;
    String versionTo;
    String rank;

    public String getName() {
        return name;
    }

    public String getId() {
        return id;
    }

    public List<String> getTags() {
        return tags;
    }

    public String getVersionFrom() {
        return versionFrom;
    }

    public String getVersionTo() {
        return versionTo;
    }

    public String getRank() {
        return rank;
    }
}

public class SearchExploit {

	public static void search(String[] args) {
        final String ANSI_RESET = "\u001B[0m";

        if (args.length < 1) {
            System.out.println("Usage: java SearchExploit <search term1> [<search term2> ...]");
            return;
        }

        List<String> searchTerms = new ArrayList<>();
        for (String arg : args) {
            searchTerms.add(arg.toLowerCase());
        }

        try (FileReader reader = new FileReader("src/org/pwnpress/exploit/modules/modules.json")) {
            StringBuilder jsonData = new StringBuilder();
            int i;
            while ((i = reader.read()) != -1) {
                jsonData.append((char) i);
            }

            JSONArray jsonArray = new JSONArray(jsonData.toString());

            // Find maximum lengths for Rank, ID, Version, and Exploit fields
            int maxRankLength = 0;
            int maxIdLength = 0;
            int maxVersionLength = 0;
            int maxExploitLength = 0;
            for (int j = 0; j < jsonArray.length(); j++) {
                JSONObject jsonObject = jsonArray.getJSONObject(j);
                Exploit exploit = parseExploit(jsonObject);
                maxRankLength = Math.max(maxRankLength, exploit.getRank().length());
                maxIdLength = Math.max(maxIdLength, exploit.getId().length());
                String versionString = getVersionString(exploit);
                maxVersionLength = Math.max(maxVersionLength, versionString.length());
                maxExploitLength = Math.max(maxExploitLength, exploit.getName().length());
            }

            System.out.println("\nRank\t   ID\t      Version\t      Exploit");
            System.out.println("--------------------------------------------------------------------------------------------");

            for (int j = 0; j < jsonArray.length(); j++) {
                JSONObject jsonObject = jsonArray.getJSONObject(j);
                Exploit exploit = parseExploit(jsonObject);
                if (matchesSearch(exploit, searchTerms)) {
                    String versionString = getVersionString(exploit);
                    String rankColor = CustomFormat.getColor(exploit.getRank());
                    System.out.printf("%s%-"+ (maxRankLength + 2) + "s%s", rankColor, exploit.getRank(), ANSI_RESET);
                    System.out.printf("%-" + (maxIdLength + 2) + "s", exploit.getId());
                    System.out.printf("%-" + (maxVersionLength + 2) + "s", versionString);
                    System.out.printf("%-" + (maxExploitLength + 2) + "s", exploit.getName());
                    System.out.println();
                }
            }
            System.out.println("");

        } catch (IOException | JSONException e) {
            System.out.println("Error reading JSON file: " + e.getMessage());
        }
    }

	private static Exploit parseExploit(JSONObject jsonObject) throws JSONException {
	    Exploit exploit = new Exploit();
	    exploit.name = jsonObject.getString("name");
	    exploit.id = jsonObject.getString("id");
	    JSONArray tagsArray = jsonObject.getJSONArray("tags");
	    exploit.tags = new ArrayList<>();
	    for (int i = 0; i < tagsArray.length(); i++) {
	        exploit.tags.add(tagsArray.getString(i));
	    }
	    Object versionObject = jsonObject.get("version");
	    if (versionObject instanceof String) {
	        exploit.versionFrom = (String) versionObject;
	        exploit.versionTo = (String) versionObject;
	    } else if (versionObject instanceof JSONObject) {
	        JSONObject versionJson = (JSONObject) versionObject;
	        exploit.versionFrom = versionJson.getString("from");
	        exploit.versionTo = versionJson.getString("to");
	    }
	    exploit.rank = jsonObject.getString("rank"); // Parse rank field
	    return exploit;
	}

    private static boolean matchesSearch(Exploit exploit, List<String> searchTerms) {
        for (String term : searchTerms) {
            boolean termFound = false;
            for (String tag : exploit.getTags()) {
                if (tag.toLowerCase().contains(term)) {
                    termFound = true;
                    break;
                }
            }
            // Check if the search term matches the version range
            if (!termFound && isVersionInRange(exploit, term)) {
                termFound = true;
            }
            if (!termFound) {
                return false;
            }
        }
        return true;
    }

    private static boolean isVersionInRange(Exploit exploit, String searchTerm) {
        String fromVersion = exploit.getVersionFrom().toLowerCase();
        String toVersion = exploit.getVersionTo().toLowerCase();
        String searchVersion = searchTerm.toLowerCase();

        if (fromVersion.equals(toVersion)) {
            return fromVersion.contains(searchVersion);
        } else {
            return searchVersion.compareTo(fromVersion) >= 0 && searchVersion.compareTo(toVersion) <= 0;
        }
    }

    private static String getVersionString(Exploit exploit) {
        if (exploit.getVersionFrom().equals(exploit.getVersionTo())) {
            return exploit.getVersionFrom();
        } else {
            return exploit.getVersionFrom() + " to " + exploit.getVersionTo();
        }
    }
}
